use strict;
use Getopt::Long;

my $arp_file;
my $unmap_file;
my $AB;
my $SM;
my $nc = 3;
my $read_file_1;
my $read_file_2;

GetOptions (
              "arpfile|m=s"      => \$arp_file,
              "unmap|u=s"        => \$unmap_file,
	      "readfile1|r1=s"   => \$read_file_1,
              "readfile2|r2=s"   => \$read_file_2,
              "nc|n=i"           => \$nc,
              "AB"               => \$AB,
              "SM"               => \$SM,
	      "help|h" => sub{
	                     print "usage: $0 [options]\n\nOptions:\n";
                             print "\t--arpfile\tthe arp file generated by Rseq_bam_stats\n";
                             print "\t--unmap\t\tunmapped reads file in fq\n";
			     print "\t--readfile1\tthe 5' end reads\n";
			     print "\t--readfile2\tthe 3' end reads\n";
                             print "\t--AB\t\twhether AB\n";
			     print "\t--help\t\tprint this help message\n";
                             exit 0;
			    }
	   );


my %ARP;  #hash to remember the anomalous read pairs


open UM, "$unmap_file";
while ( <UM> ) {
   chomp;
   my $frag_name;
   if ($_ =~ /^@(.+?)\s+/) {
      $frag_name = $1;
   }
   elsif ($_ =~ /^@(\S+)$/) {
      $frag_name = $1;
   }
   $frag_name =~ s/\/[12].*?$//;  #replace the end

   if ($AB) {
     $frag_name =~ s/^(.+)[AB]$/\1/;
   }
   $ARP{$frag_name} = '';

   $_ = <UM>;
   $_ = <UM>;
   $_ = <UM>;
}
close UM;
print STDERR "unmapped file loaded\n";


open ARP, "$arp_file";
while ( <ARP> ) {
   chomp;
   if ($AB) {
     $_ =~ s/^(.+)[AB]$/\1/;
   }
   $ARP{$_} = '';
}
close ARP;
print STDERR "ARP file loaded\n";


open R1P, "$read_file_1";
while ( <R1P> ) {
  chomp;
  if ($_ =~ /^@(.+?)[\/\s]/) {
     my $frag_name = $1;
     if (exists $ARP{$frag_name}) {

        $_ = <R1P>; #sequence
        chomp;
        my $n = 0;
        while ($_ =~ /N/g){
          $n++;
        }
        if ($n >= $nc){
          delete ($ARP{$frag_name}); #delete this frag
        }

        $_ = <R1P>;
        $_ = <R1P>; #quality
     }
     else {
        $_ = <R1P>;
        $_ = <R1P>;
        $_ = <R1P>;
     }
  }
}
close R1P;

open R2P, "$read_file_2";
while ( <R2P> ) {
  chomp;
  if ($_ =~ /^@(.+?)[\/\s]/){
     my $frag_name = $1;
     if (exists $ARP{$frag_name}) {

        $_ = <R2P>; #sequence
        chomp;
        my $n = 0;
        while ($_ =~ /N/g){
          $n++;
        }
        if ($n >= $nc){
          delete ($ARP{$frag_name}); #delete this frag
        }

        $_ = <R2P>;
        $_ = <R2P>; #quality
     }
     else {
        $_ = <R2P>;
        $_ = <R2P>;
        $_ = <R2P>;
     }
  }
}
close R2P;


open R1, "$read_file_1";
my $a_R1 = $read_file_1;
if($SM){
 $a_R1 =~ s/fq$/ARP\.secondmapping\.fq/;
}
else{
 $a_R1 =~ s/fq$/ARP\.fq/;
}
open AR1, ">$a_R1";
while ( <R1> ) {
  chomp;
  if ($_ =~ /^@(.+?)[\/\s]/) {
     my $frag_name = $1;
     if (exists $ARP{$frag_name}) {
        print AR1 "$_\n";
        $_ = <R1>;
        print AR1 "$_";
        $_ = <R1>;
        print AR1 "$_";
        $_ = <R1>;
        print AR1 "$_";
     }
     else {
        $_ = <R1>;
        $_ = <R1>;
        $_ = <R1>;
     }
  }
}
close R1;
close AR1;


open R2, "$read_file_2";
my $a_R2 = $read_file_2;
if($SM){
 $a_R2 =~ s/fq$/ARP\.secondmapping\.fq/;
}
else{
 $a_R2 =~ s/fq$/ARP\.fq/;
}
open AR2, ">$a_R2";
while ( <R2> ){
  chomp;
  if ($_ =~ /^@(.+?)[\/\s]/){
     my $frag_name = $1;
     if (exists $ARP{$frag_name}) {
        print AR2 "$_\n";
        $_ = <R2>;
        print AR2 "$_";
        $_ = <R2>;
        print AR2 "$_";
        $_ = <R2>;
        print AR2 "$_";
     }
     else {
        $_ = <R2>;
        $_ = <R2>;
        $_ = <R2>;
     }
  }
}
close R2;
close AR2;
